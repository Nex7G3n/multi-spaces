import time
from datetime import date
import pandas as pd
import numpy as np
from infrastructure.adapters.out.connectors.base_connector import BaseConnector


class OracleConnector(BaseConnector):
    """Connector para Oracle Database (probado con Oracle XE 11g)."""

    def __init__(self, db_type: str = "Oracle"):
        super().__init__(db_type)

    def connect(self, host: str, port: int, service_name: str, user: str, password: str):
        try:
            import cx_Oracle
        except ImportError:
            raise RuntimeError(
                "El conector 'cx_Oracle' no está instalado. Por favor, instala 'cx_Oracle'."
            )

        dsn = cx_Oracle.makedsn(host, port, service_name=service_name)
        self.connection = cx_Oracle.connect(user=user, password=password, dsn=dsn)
        self.cursor = self.connection.cursor()

    def disconnect(self):
        if self.connection:
            self.connection.close()
            self.connection = None
            self.cursor = None

    def execute_query(self, query, params=None):
        start_time = time.time()
        try:
            if params:
                self.cursor.execute(query, params)
            else:
                self.cursor.execute(query)
            execution_time = (time.time() - start_time) * 1000
            return self.cursor, execution_time
        except Exception:
            if self.connection:
                self.connection.rollback()
            raise

    def execute_sp(self, sp_name, params):
        start_time = time.time()
        try:
            self.cursor.callproc(sp_name, params)
            result = None
            if self.cursor.description:
                result = self.cursor.fetchone()
            execution_time = (time.time() - start_time) * 1000
            return result, execution_time
        except Exception:
            if self.connection:
                self.connection.rollback()
            raise

    def measure_time(self, operation_name, func, *args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        execution_time = (time.time() - start_time) * 1000
        return result, execution_time

    # --- Métodos de esquema y datos ---
    def create_tables(self):
        queries = [
            """CREATE TABLE Clientes (
                cliente_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nombre VARCHAR2(100),
                email VARCHAR2(100),
                telefono VARCHAR2(20),
                direccion VARCHAR2(200)
            )""",
            """CREATE TABLE Personal (
                personal_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nombre VARCHAR2(100),
                rol VARCHAR2(50)
            )""",
            """CREATE TABLE Producto (
                producto_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nombre VARCHAR2(100),
                precio NUMBER(10,2),
                stock NUMBER
            )""",
            """CREATE TABLE Factura (
                factura_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                cliente_id NUMBER,
                personal_id NUMBER,
                fecha DATE,
                total NUMBER(10,2),
                FOREIGN KEY (cliente_id) REFERENCES Clientes(cliente_id),
                FOREIGN KEY (personal_id) REFERENCES Personal(personal_id)
            )""",
            """CREATE TABLE Detalle_Factura (
                detalle_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                factura_id NUMBER,
                producto_id NUMBER,
                cantidad NUMBER,
                precio_unitario NUMBER(10,2),
                subtotal NUMBER(10,2),
                FOREIGN KEY (factura_id) REFERENCES Factura(factura_id),
                FOREIGN KEY (producto_id) REFERENCES Producto(producto_id)
            )""",
        ]
        for query in queries:
            try:
                self.execute_query(query)
                self.connection.commit()
            except Exception as e:
                print(f"ERROR CONNECTOR Oracle al crear tabla: {e}")
                self.connection.rollback()

    def create_stored_procedures(self):
        sp_query = """
        CREATE OR REPLACE PROCEDURE sp_generar_factura(
            p_cliente_id IN NUMBER,
            p_personal_id IN NUMBER,
            p_productos_json IN CLOB,
            o_factura_id OUT NUMBER,
            o_total OUT NUMBER
        ) AS
            v_total NUMBER(10,2) := 0;
        BEGIN
            INSERT INTO Factura (cliente_id, personal_id, fecha, total)
            VALUES (p_cliente_id, p_personal_id, SYSDATE, 0)
            RETURNING factura_id INTO o_factura_id;

            FOR rec IN (
                SELECT * FROM json_table(p_productos_json, '$[*]' COLUMNS (
                    producto_id NUMBER PATH '$.producto_id',
                    cantidad NUMBER PATH '$.cantidad'))
            ) LOOP
                DECLARE
                    v_precio NUMBER(10,2);
                    v_subtotal NUMBER(10,2);
                BEGIN
                    SELECT precio INTO v_precio FROM Producto WHERE producto_id = rec.producto_id;
                    v_subtotal := rec.cantidad * v_precio;
                    INSERT INTO Detalle_Factura (factura_id, producto_id, cantidad, precio_unitario, subtotal)
                    VALUES (o_factura_id, rec.producto_id, rec.cantidad, v_precio, v_subtotal);
                    v_total := v_total + v_subtotal;
                END;
            END LOOP;

            UPDATE Factura SET total = v_total WHERE factura_id = o_factura_id;
            o_total := v_total;
        END;
        """
        try:
            self.cursor.execute(sp_query)
            self.connection.commit()
        except Exception as e:
            print(f"ERROR CONNECTOR Oracle al crear SP: {e}")
            self.connection.rollback()

    def generate_test_data(self):
        num_records = 500
        clientes_data = []
        personal_data = []
        productos_data = []
        for i in range(1, num_records + 1):
            clientes_data.append((f'Cliente {i}', f'cliente{i}@example.com', f'111-222-{i:04d}', f'Dir {i}'))
            personal_data.append((f'Vendedor {i}', 'Vendedor'))
            productos_data.append((f'Producto {i}', 10.00 + i * 0.5, 100 + i))
        try:
            if self.is_table_empty("CLIENTES"):
                self.cursor.executemany(
                    "INSERT INTO Clientes (nombre, email, telefono, direccion) VALUES (:1, :2, :3, :4)",
                    clientes_data,
                )
            if self.is_table_empty("PERSONAL"):
                self.cursor.executemany(
                    "INSERT INTO Personal (nombre, rol) VALUES (:1, :2)",
                    personal_data,
                )
            if self.is_table_empty("PRODUCTO"):
                self.cursor.executemany(
                    "INSERT INTO Producto (nombre, precio, stock) VALUES (:1, :2, :3)",
                    productos_data,
                )
            self.connection.commit()
        except Exception as e:
            print(f"ERROR CONNECTOR Oracle datos de prueba: {e}")
            self.connection.rollback()

    def fetch_all_records(self, table_name):
        query = f"SELECT * FROM {table_name}"
        self.cursor.execute(query)
        columns = [col[0] for col in self.cursor.description]
        data = self.cursor.fetchall()
        return pd.DataFrame(data, columns=columns)

    def insert_record(self, table_name, data):
        processed = {}
        for k, v in data.items():
            if isinstance(v, (int, np.integer)):
                processed[k] = int(v)
            elif isinstance(v, (float, np.floating)):
                processed[k] = float(v)
            elif isinstance(v, date):
                processed[k] = v.strftime('%Y-%m-%d')
            else:
                processed[k] = v
        columns = ', '.join(processed.keys())
        placeholders = ', '.join([f":{i+1}" for i in range(len(processed))])
        query = f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})"
        try:
            self.cursor.execute(query, tuple(processed.values()))
            self.connection.commit()
        except Exception as e:
            print(f"ERROR CONNECTOR Oracle insert: {e}")
            self.connection.rollback()
            raise

    def update_record(self, table_name, record_id, data):
        processed = {}
        for k, v in data.items():
            if isinstance(v, (int, np.integer)):
                processed[k] = int(v)
            elif isinstance(v, (float, np.floating)):
                processed[k] = float(v)
            elif isinstance(v, date):
                processed[k] = v.strftime('%Y-%m-%d')
            else:
                processed[k] = v
        set_clause = ', '.join([f"{col} = :{i+1}" for i, col in enumerate(processed.keys())])
        pk_col_map = {
            'clientes': 'cliente_id',
            'personal': 'personal_id',
            'producto': 'producto_id',
            'factura': 'factura_id',
            'detalle_factura': 'detalle_id'
        }
        pk_col = pk_col_map.get(table_name.lower(), 'id')
        query = f"UPDATE {table_name} SET {set_clause} WHERE {pk_col} = :{len(processed)+1}"
        params = tuple(list(processed.values()) + [record_id])
        try:
            self.cursor.execute(query, params)
            self.connection.commit()
        except Exception as e:
            print(f"ERROR CONNECTOR Oracle update: {e}")
            self.connection.rollback()
            raise

    def delete_record(self, table_name, record_id):
        pk_col_map = {
            'clientes': 'cliente_id',
            'personal': 'personal_id',
            'producto': 'producto_id',
            'factura': 'factura_id',
            'detalle_factura': 'detalle_id'
        }
        pk_col = pk_col_map.get(table_name.lower(), f"{table_name.lower()}_id")
        query = f"DELETE FROM {table_name} WHERE {pk_col} = :1"
        try:
            self.cursor.execute(query, (record_id,))
            self.connection.commit()
        except Exception as e:
            print(f"ERROR CONNECTOR Oracle delete: {e}")
            self.connection.rollback()
            raise

    def search_client(self, client_id: int = 1):
        query = "SELECT * FROM Clientes WHERE cliente_id = :1"
        cursor, exec_time = self.execute_query(query, (client_id,))
        return cursor.fetchone(), exec_time

    def search_product(self, product_id: int = 1):
        query = "SELECT * FROM Producto WHERE producto_id = :1"
        cursor, exec_time = self.execute_query(query, (product_id,))
        return cursor.fetchone(), exec_time

    def generate_invoice(self, client_id: int, staff_id: int, products_json_str: str):
        result_vars = self.cursor.var(int), self.cursor.var(float)
        result, exec_time = self.execute_sp(
            "sp_generar_factura",
            (client_id, staff_id, products_json_str, result_vars[0], result_vars[1])
        )
        self.connection.commit()
        return (result_vars[0].getvalue(), result_vars[1].getvalue()), exec_time

    def query_invoice(self, invoice_id: int = 1):
        query = "SELECT * FROM Factura WHERE factura_id = :1"
        cursor, exec_time = self.execute_query(query, (invoice_id,))
        return cursor.fetchone(), exec_time

    def sales_report(self):
        query = """
        SELECT p.nombre AS producto,
               SUM(df.cantidad) AS total_vendido,
               SUM(df.subtotal) AS ingresos_totales
        FROM Detalle_Factura df
        JOIN Producto p ON df.producto_id = p.producto_id
        GROUP BY p.nombre
        ORDER BY ingresos_totales DESC"""
        cursor, exec_time = self.execute_query(query)
        return cursor.fetchall(), exec_time

    def is_table_empty(self, table_name):
        query = f"SELECT COUNT(*) FROM {table_name}"
        self.cursor.execute(query)
        count = self.cursor.fetchone()[0]
        return count == 0
